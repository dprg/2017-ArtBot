/****************************************************************
parse_tst01.c
Post processor for files generated by F-Engrave.
Assumes files generated using F-Engrave configure file



****************************************************************/
#include<stdio.h>
#include<string.h>
#include<math.h>

#define MAX_SIZE 100
#define MAX_DIST 180      // in mm
#define Z_OFFSET -15.0     // in mm
#define BRUSH_DIP 2.5        // in mm
#define SAFE_HEIGHT 20.0     // in mm   

enum tokens {
	CMD = 0,
    X = 1,
    Y = 2,
    Z = 3,
    F = 4,
};

enum coordinates {
	X1 = 0,
	Y1 = 1,
	X2 = 2,
	Y2 = 3,
	Z1 = 4,
};
enum colors {
	RED = 0,
	BLK = 1,
	GRN = 2,
	BLK_DARK = 3,
};

/** Function declaration */
int indexOf(const char * text, const char toFind);
float dist_of_move ( float *xy_array);
void mach_setup ();
void pause_mach (int seconds);
void get_paint ();
void mach_end ();

/* variables */
int color = BLK_DARK;
int seconds = 30;
FILE *f_in,*f_out;
char z_restore_flg = 0;

int main()
{
	
	char buf[MAX_SIZE];
	char temp[MAX_SIZE];
    char toFind;
    int index;
	float move_dist,dist;
	int token_loc[7];
	float token_val[7] = {0,0,0,0,0,0,0};

		
	f_in =fopen("wo_dark_clean.ngc","r");
	if (!f_in)
		return 1;
	f_out =fopen("wo_dark_clean.gcode","w");
	
	mach_setup ();
	get_paint ();

	while (fgets(buf,MAX_SIZE, f_in)!=NULL){  // get a line from the input file
		// len of original line
		int buf_len = strlen(buf);
		printf("original buf len =  %d\n",buf_len);
		// flg to restore z after get paint (set to 1 by get paint routine)
		if (z_restore_flg == 1) 
			z_restore_flg = 2;
		
		//fprintf (f_out, "%s",buf);        // copy line to output file
		
		// store Z value (for reinsertion after get paint call)
		toFind = 'Z';
		index = indexOf (buf, toFind);
		if(index == -1) {                  // no Z found
			//printf("'%c' not found.\n", toFind);
			fprintf (f_out, "%s",buf);        // copy line to output file
		}
		else {                            // Z found
			strcpy(temp, &buf[index + 1]);
			sscanf(temp,"%f",&token_val[Z1]);
			// z offset code 
			//printf("z =  %f\n",token_val[Z1]);
			token_val[Z1] -= Z_OFFSET;
			//printf("z - zoffset =  %.3f\n",token_val[Z1]);
			char stemp[12];  // with a little extra room
			sprintf( stemp, "%.3f", token_val[Z1] );
			int stemp_len = strlen(stemp);

			int j;
			for (j = 0; j <=  stemp_len; j++) {
				buf[index + 1 + j] = stemp[j];
			}

			fprintf (f_out, "%s\n",buf);        // copy line to output file
		}
		
		// find X and Y values to do dist calc
		toFind = 'X';
		index = indexOf(buf, toFind);
		if(index == -1) {                  // no X found
			//printf("'%c' not found.\n", toFind);
		}
		else {                             // found matching char
			//token_loc[X] = index;
			strcpy(temp, &buf[index + 1]);
			//printf("%s",temp);
			sscanf(temp,"%f",&token_val[X1]);
			toFind = 'Y';
			index = indexOf(temp,toFind);
			if(index == -1)  {             // X without matching Y found
				
				//printf("'%c' not found.\n", toFind);
			}
			else{                         // found matching char
				strcpy(temp, &temp[index + 1]);
				//printf("%s",temp);
				sscanf(temp,"%f",&token_val[Y1]);
				//token_loc[Y] = index;
				//printf("x: %f  y:  %f\n", token_val[X1],token_val[Y1]);
				dist = dist_of_move (token_val);
				move_dist += dist;
				//printf("dist =  %f\n",move_dist);
				
				//printf("x1:  %f   y1:  %f\n",token_val[X1],token_val[Y1]);
				//printf("x2:  %f   y2:  %f\n",token_val[X2],token_val[Y2]);
				
				token_val[X2] = token_val[X1];
				token_val[Y2] = token_val[Y1];
				
				// restore Z value
				if (z_restore_flg == 2) {
					buf[strlen(buf)-1] = 0;      // remove last char from buf (ie. \n) 
					fprintf (f_out, "%s Z%.3f                    ; restore Z value\n",buf,token_val[Z1]);
					z_restore_flg = 0;
				}
				
				if (move_dist >= MAX_DIST) {
					//printf("New Paint dist =  %f\n",move_dist);
					get_paint ();
					
					fprintf (f_out, "; Distance since last new paint =  %f\n",move_dist);
					move_dist = 0;
				}
				
			}
		}

	}	
	
	mach_end ();
	fclose(f_in);
	fclose(f_out);
		return 0;
	}
	
// --------------------------- functions ------------------------------------------	
	
/**********************************************************************
 * Returns the first index of the given character toFind in the string. 
 * If returns -1 if the given character toFind does not exists in the string.
 *********************************************************************/
int indexOf(const char * text, const char toFind)
{
    int index = -1; // Assumes that the character doesn't exists
    int i, len;
 
    len = strlen(text);
 
    for(i=0; i<len; i++)
    {
        if(text[i] == toFind)
        {
            index = i;
            break;
        }
    }
 
    return index;
} 

/**********************************************************************
 * Takes two pairs of XY values and calculates the distance
 * between the two pair of coordinates.
 *********************************************************************/
float dist_of_move (float *xy_array)
{
	float dist;
	float x_delta, y_delta;
	
	x_delta = (float)(xy_array[X2] - xy_array[X1]);
	y_delta = (float)(xy_array[Y2] - xy_array[Y1]);
	
	//printf("x_delta:  %f   y_delta:  %f\n",x_delta,y_delta);
	
	dist = (float) sqrt(x_delta * x_delta + y_delta * y_delta); 
	
	return dist;
}

void mach_setup () 
{
	fprintf (f_out, "; setup\n");
	fprintf (f_out, "G21                       ; [mm] mode\n");
	fprintf (f_out, "G90                       ; absolute mode\n");
	fprintf (f_out, "M82                       ; set extruder to absolute mode\n");
	fprintf (f_out, "G28                       ; home\n");
	fprintf (f_out, "G92 E0                    ; set extruder position to zero\n");
	//fprintf (f_out, "M206 Z10                  ; add 10mm of Z offset\n");
	fprintf (f_out, "G1 X74 Y120 Z%.3f F2000      ; move to starting position",-Z_OFFSET);
	fprintf (f_out, "; end of setup\n");
	fprintf (f_out, "; place brush in holder\n");
	pause_mach(30);
	fprintf (f_out, "; end of brush placement\n");
}

void pause_mach (int seconds)
{
	fprintf (f_out, "G4 S%i                    ; stop for %i secs.\n",seconds,seconds);
}

void get_paint () 
{
	fprintf (f_out, "; get water\n");
	fprintf (f_out, "G1 Z%.3f                 ; raise zto safe ht to prevent drag\n",SAFE_HEIGHT);
	if (color == RED) {// red
		fprintf (f_out, "G1	X35 Y28 Z40 F5000   ; raise brush over water tank\n");
		fprintf (f_out, "G1	X35 Y28 Z%.3f  F5000   ; dip brush in water\n",-Z_OFFSET + BRUSH_DIP );  
		fprintf (f_out, "G1	X35 Y28 Z35 F5000   ; raise brush over water tank\n");
	}
	if (color == BLK){// blk
		fprintf (f_out, "G1	X60 Y28 Z40 F5000   ; raise brush over water tank\n");
		fprintf (f_out, "G1	X60 Y28 Z%.3f  F5000   ; dip brush in water\n",-Z_OFFSET + BRUSH_DIP );  
		fprintf (f_out, "G1	X60 Y28 Z35 F5000   ; raise brush over water tank\n");
	}
	if (color == GRN){// green
		fprintf (f_out, "G1	X105 Y28 Z40 F5000   ; raise brush over water tank\n");
		fprintf (f_out, "G1	X105 Y28 Z%.3f  F5000   ; dip brush in water\n",-Z_OFFSET + BRUSH_DIP );  
		fprintf (f_out, "G1	X105 Y28 Z35 F5000   ; raise brush over water tank\n");
	}
	if (color == BLK_DARK){// blk-dark - same water as blk
		fprintf (f_out, "G1	X60 Y28 Z40 F5000   ; raise brush over water tank\n");
		fprintf (f_out, "G1	X60 Y28 Z%.3f  F5000   ; dip brush in water\n",-Z_OFFSET + BRUSH_DIP );  
		fprintf (f_out, "G1	X60 Y28 Z35 F5000   ; raise brush over water tank\n");
	}
	
	
	fprintf (f_out, "; end of get water\n");
	fprintf (f_out, "; get paint\n");
	
	if (color == RED){// red
		fprintf (f_out, "G1	X10	Y28	Z35	F5000   ; raise brush over paint\n");
		fprintf (f_out, "G1	X10	Y28	Z%.3f	F5000   ; dip into paint\n",-Z_OFFSET + BRUSH_DIP );
		fprintf (f_out, "G1	X10	Y28	Z40	F5000   ; raise brush over paint\n");
	}
	if (color == BLK){// blk
		fprintf (f_out, "G1	X85	Y28	Z35	F5000   ; raise brush over paint\n");
		fprintf (f_out, "G1	X85	Y28	Z%.3f	F5000   ; dip into paint\n",-Z_OFFSET + BRUSH_DIP );
		fprintf (f_out, "G1	X85	Y28	Z40	F5000   ; raise brush over paint\n");
	}
	if (color == GRN) { // green
		fprintf (f_out, "G1	X130 Y28 Z35	F5000   ; raise brush over paint\n");
		fprintf (f_out, "G1	X130 Y28 Z%.3f	F5000   ; dip into paint\n",-Z_OFFSET + BRUSH_DIP );
		fprintf (f_out, "G1	X130 Y28 Z40	F5000   ; raise brush over paint\n");	
	}
	if (color == BLK_DARK) { // blk-dark
		fprintf (f_out, "G1	X168 Y58 Z35	F5000   ; raise brush over paint\n");
		fprintf (f_out, "G1	X168 Y58 Z%.3f	F5000   ; dip into paint\n",-Z_OFFSET + BRUSH_DIP );
		fprintf (f_out, "G1	X168 Y58 Z40	F5000   ; raise brush over paint\n");	
	}
	
	fprintf (f_out, "; end of get paint\n");
	z_restore_flg = 1;
	
}

void mach_end ()
{
	fprintf (f_out, "; raise brush at end of job\n");
	fprintf (f_out, "G1	X74	Y120 Z50 F2000  ; raise brush over paint\n");
	//fprintf (f_out, "M206 Z-10                 ; remove Z offset of 10mm\n");
	fprintf (f_out, "; end\n");
}
	